// RUN: rm -rf %t
// RUN: mkdir -p %t
// RUN: %S/../../utils/gyb %s -o %t/FixedPointConversion.swift
// RUN: %S/../../utils/line-directive %t/FixedPointConversion.swift -- %target-build-swift %t/FixedPointConversion.swift -o %t/a.out_Debug
// RUN: %S/../../utils/line-directive %t/FixedPointConversion.swift -- %target-build-swift %t/FixedPointConversion.swift -o %t/a.out_Release -O
//
// RUN: %S/../../utils/line-directive %t/FixedPointConversion.swift -- %target-run %t/a.out_Debug
// RUN: %S/../../utils/line-directive %t/FixedPointConversion.swift -- %target-run %t/a.out_Release
// REQUIRES: executable_test

%{

from SwiftIntTypes import all_integer_types

word_bits = 4

def intMax(bits, signed): 
    bits = bits - 1 if signed else bits 
    return (1 << bits) - 1
    
def intMin(bits, signed):
  return -1 * intMax(bits, signed) - 1 if signed else 0

floatNameToSignificandBits = { 'Float32':24, 'Float64':53, 'Float80':64 }
  
}%

import StdlibUnittest

var FixedPointConversionTraps = TestSuite("FixedPointToFixedPointConversionTraps")
var FixedPointConversionFailure = TestSuite("FixedPointToFixedPointConversionFailures")

var FloatingPointConversionTruncations = TestSuite("FloatingPointToFixedPointConversionTruncations")
var FloatingPointConversionFailure = TestSuite("FloatingPointToFixedPointConversionFailures")

% for self_ty in all_integer_types(word_bits):
%   selfBits = self_ty.bits
%   selfSigned = self_ty.is_signed
%   selfMin = intMin(selfBits, selfSigned)
%   selfMax = intMax(selfBits, selfSigned)
%   Self = self_ty.stdlib_name

%   for other_ty in all_integer_types(word_bits):
%     otherBits = other_ty.bits
%     otherSigned = other_ty.is_signed
%     otherMin = intMin(otherBits, otherSigned)
%     otherMax = intMax(otherBits, otherSigned)
%     Other = other_ty.stdlib_name

%     for testValue in [selfMin, selfMax, selfMin - 1, selfMax + 1, otherMin, otherMax]:

%       if testValue < otherMin or testValue > otherMax: 
%          # Do nothing/continue.

%       elif testValue >= selfMin and testValue <= selfMax:

/// Always-safe conversion from ${Other}(${testValue}) to ${Self}.
FixedPointConversionTraps.test("${Other}To${Self}Conversion/dest=${testValue}") {
  // Test that nothing interesting happens and we end up with the same result after converting.
  let input = get${Other}(${testValue})
  let result = ${Self}(input)
  expectEqual(${testValue}, result)
  _blackHole(result)
}

/// Never-nil failable conversion from ${Other}(${testValue}) to ${Self}.
FixedPointConversionFailure.test("${Other}To${Self}FailableConversion/dest=${testValue}") {
  // Test that nothing interesting happens and we end up with a non-nil, identical result.
  let input = get${Other}(${testValue})
  var result = ${Self}(exactly: input)
  expectNotEqual(result, nil)
  expectEqual(${testValue}, result)
  _blackHole(result)
}

%       else:

/// Always-failing conversion from ${Other}(${testValue}) to ${Self}.
FixedPointConversionTraps.test("${Other}To${Self}Conversion/dest=${testValue}") {
  // Test that we check if we fail and crash when an integer would be truncated in conversion.
  let input = get${Other}(${testValue})
  expectCrashLater()
  var result = ${Self}(input)
  _blackHole(result)
}

/// Always-nil failable conversion from ${Other}(${testValue}) to ${Self}.
FixedPointConversionFailure.test("${Other}To${Self}Conversion/dest=${testValue}") {
  // Test that we check if we return nil when an integer would be truncated in conversion.
  let input = get${Other}(${testValue})
  var result = ${Self}(exactly: input)
  expectEqual(nil, result)
  _blackHole(result)
}
%       end

%     end # for testValue in ...
%   end # for in all_integer_types (Other)

%   for Other, otherSignificandBits in floatNameToSignificandBits.iteritems():
%     otherMin = intMin(otherSignificandBits, False)
%     otherMax = intMax(otherSignificandBits, False)

%     if Other == 'Float80':
#if arch(i386) || arch(x86_64)
%     end

%     for testValue in [selfMin, selfMax, selfMin - 1.0, selfMax + 1.0, otherMin, otherMax, 0.0, -0.0, 0.1, -0.1]:
        
%       if testValue < otherMin or testValue > otherMax: 
%          # Do nothing/continue.

%       elif testValue >= selfMin and testValue <= selfMax and testValue % 1 == 0:

/// Always-safe conversion from ${Other}(${testValue}) to ${Self}.
FloatingPointConversionTruncations.test("${Other}To${Self}Conversion/dest=${testValue}") {
  // Test that nothing interesting happens and we end up with the same result after converting.
  let input = get${Other}(${testValue})
  let result = ${Self}(input)
  var resultConvertedBack = ${Other}(result)
  expectEqual(${testValue}, resultConvertedBack)
}

/// Never-nil failable conversion from ${Other}(${testValue}) to ${Self}.
FloatingPointConversionFailure.test("${Other}To${Self}FailableConversion/dest=${testValue}") {
  // Test that nothing interesting happens and we end up with a non-nil, identical result.
  let input = get${Other}(${testValue})
  var result = ${Self}(exactly: input)
  expectNotEqual(result, nil)
}

%       else:

/// Always-truncating conversion from ${Other}(${testValue}) to ${Self}.
FloatingPointConversionTruncations.test("${Other}To${Self}Conversion/dest=${testValue}") {
  // Test that we check if we fail and crash when an integer would be truncated in conversion.
  let input = get${Other}(${testValue})
  var result = ${Self}(input)
  var resultConvertedBack = ${Other}(result)
  expectNotEqual(input, resultConvertedBack)
}

/// Always-nil failable conversion from ${Other}(${testValue}) to ${Self}.
FloatingPointConversionFailure.test("${Other}To${Self}Conversion/dest=${testValue}") {
  // Test that we check if we return nil when an integer would be truncated in conversion.
  let input = get${Other}(${testValue})
  var result = ${Self}(exactly: input)
  expectEqual(nil, result)
}
%       end

%     end # for in testValues

%     if Other == 'Float80':
#endif
%     end

%   end # for in floatNameToSignificandBits (Other)
% end # for in all_integer_types (Self)

runAllTests()
